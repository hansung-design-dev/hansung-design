# 🎯 Banner 가격 정책 최적화 분석 및 해결 방안

## 📋 현재 상황 분석

### 🔍 문제점

1. **가격 정보 누락**: `banner_slot_price_policy` 테이블에 데이터가 없음
2. **원인**: `banner_slots` 테이블 개편 과정에서 가격 정책 데이터 손실
3. **구조적 문제**: 각 게시대의 모든 면(slot)에 대해 개별 가격 정책이 생성되어 불필요한 데이터 중복

### 🏗️ 현재 구조의 문제점

```sql
-- 현재: 각 면마다 개별 가격 정책
banner_slots (관악구 게시대 1 - 6개 면)
├── slot_1 → banner_slot_price_policy (상업용: 112,300원)
├── slot_2 → banner_slot_price_policy (상업용: 112,300원)
├── slot_3 → banner_slot_price_policy (상업용: 112,300원)
├── slot_4 → banner_slot_price_policy (상업용: 112,300원)
├── slot_5 → banner_slot_price_policy (상업용: 112,300원)
└── slot_6 → banner_slot_price_policy (상업용: 112,300원)
```

**문제**: 같은 패널의 모든 면이 동일한 가격인데 6개의 중복 레코드 생성

### 🎯 한성의 비즈니스 모델

- **선착순 방식**: 관악구 게시대 1의 6개 면 중 아래서부터 순차적으로 채워짐
- **면 번호 무관**: 몇 번째 면이 구매되었는지는 중요하지 않음
- **패널 단위 관리**: 게시대 전체를 하나의 단위로 관리

---

## 💡 해결 방안

### 🎯 방법 1: banner_slots 유지 + 가격 정책 최적화 (추천)

#### 핵심 아이디어

- `banner_slots`: 모든 면 정보 유지 (확장성 고려)
- **가격 정책**: 패널별 대표 슬롯(slot_number = 1)만 가격 정책 연결
- **재고 관리**: 면별 개별 관리하되, 가격은 대표 슬롯 기준

#### 최적화된 구조

```sql
-- 최적화 후: 패널별 대표 슬롯만 가격 정책
banner_slots (관악구 게시대 1 - 6개 면)
├── slot_1 → banner_slot_price_policy (상업용: 112,300원) ← 대표 슬롯
├── slot_2 → (가격 정책 없음)
├── slot_3 → (가격 정책 없음)
├── slot_4 → (가격 정책 없음)
├── slot_5 → (가격 정책 없음)
└── slot_6 → (가격 정책 없음)
```

#### 장점 ✅

- **기존 구조 호환성**: 최소한의 코드 수정
- **확장성**: 향후 면별 세부 관리 필요 시 대응 가능
- **데이터 무결성**: `banner_slots`의 모든 정보 보존
- **재고 관리**: 면별 개별 재고 관리 유지
- **가격 중복 제거**: 패널당 1개 가격 정책만 유지

#### 단점 ❌

- 가격 정책 테이블에 여전히 일부 중복 존재 (패널별로는 중복 제거)

---

### 🎯 방법 2: 지역별 가격표 방식

#### 핵심 아이디어

- `banner_slot_price_policy` 테이블 완전 제거
- 새로운 `region_banner_price_policy` 테이블 생성
- 지역-용도별로 하나의 가격 정책만 관리

#### 새로운 구조

```sql
-- 지역별 가격표 방식
region_banner_price_policy
├── 관악구
│   ├── 상업용: 112,300원
│   └── 행정용: 69,300원
├── 강북구
│   ├── 상업용: 98,500원
│   └── 행정용: 62,100원
└── ...
```

#### 장점 ✅

- **데이터 중복 완전 제거**: 지역별로 하나의 가격 정책만
- **관리 용이성**: 지역별 가격 변경 시 한 번만 수정
- **일관성**: 같은 지역 내 모든 패널이 동일한 가격
- **확장성**: 새로운 지역 추가 시 간단

#### 단점 ❌

- **개별 패널별 차별화 가격 설정 불가**
- **기존 코드 대폭 수정 필요**
- **마이그레이션 작업 복잡**

---

## 🚀 구현 계획

### 📅 단계별 실행 계획

#### Phase 1: 방법 1 구현 (즉시 실행 가능)

1. **백업 생성**

   ```sql
   CREATE TABLE banner_slot_price_policy_backup AS
   SELECT * FROM banner_slot_price_policy;
   ```

2. **가격 정책 최적화 함수 실행**

   ```sql
   SELECT optimize_banner_price_policy();
   ```

3. **불필요한 가격 정책 정리**
   ```sql
   SELECT cleanup_redundant_price_policies();
   ```

#### Phase 2: 코드 적용

1. **기존 가격 조회 로직 수정**

   - `get_banner_panel_price()` 함수 사용
   - 패널 ID 기준으로 가격 조회

2. **주문 가격 계산 로직 수정**
   - `calculate_banner_order_price()` 함수 사용
   - 수량 × 단가 계산

#### Phase 3: 모니터링 및 검증

1. **가격 정책 현황 확인**

   ```sql
   SELECT * FROM banner_price_policy_summary;
   ```

2. **테스트 주문 생성 및 가격 검증**

---

## 📊 비교 분석

| 항목               | 방법 1     | 방법 2    |
| ------------------ | ---------- | --------- |
| **구현 복잡도**    | ⭐⭐       | ⭐⭐⭐⭐  |
| **기존 코드 수정** | 최소       | 대폭      |
| **데이터 중복**    | 부분 제거  | 완전 제거 |
| **확장성**         | 높음       | 보통      |
| **관리 용이성**    | 보통       | 높음      |
| **안정성**         | 높음       | 보통      |
| **추천도**         | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐  |

---

## 🎯 최종 추천: 방법 1

### 선택 이유

1. **현실적 고려사항**: 운영 중인 시스템의 안정성 우선
2. **개발 효율성**: 기존 코드 수정 최소화
3. **확장성**: 향후 면별 세부 관리 필요 시 대응 가능
4. **데이터 무결성**: `banner_slots`의 모든 정보 보존

### 예상 효과

- **데이터 중복**: 80% 이상 감소 (패널당 1개 가격 정책)
- **관리 효율성**: 패널별 가격 변경 시 한 번만 수정
- **시스템 안정성**: 기존 구조 유지로 안정적 운영
- **개발 시간**: 최소한의 수정으로 빠른 적용 가능

---

## 📝 다음 단계

1. **즉시 실행**: `optimize_banner_price_policy.sql` 스크립트 실행
2. **테스트**: 가격 조회 및 주문 생성 테스트
3. **모니터링**: 가격 정책 현황 지속적 확인
4. **문서화**: 변경된 가격 조회 로직 문서화

---

## 🔗 관련 파일

- `sqls/optimize_banner_price_policy.sql` - 방법 1 구현 스크립트
- `sqls/region_based_price_policy.sql` - 방법 2 구현 스크립트
- `docs/banner_price_policy_optimization_analysis.md` - 이 문서
